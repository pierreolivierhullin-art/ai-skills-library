# Études de cas — Auth & Security

## Cas 1 : Migration vers une architecture Zero Trust

### Contexte
MédiCloud, éditeur SaaS santé de 70 personnes, héberge des données de santé (HDS) pour 150 établissements hospitaliers et cliniques privées en France. L'entreprise est un acteur de référence dans le secteur de la gestion des dossiers patients numériques, avec une croissance de 40% par an. L'architecture repose sur un réseau privé (VPC) avec des services communiquant en HTTP non chiffré en interne, un VPN pour l'accès des développeurs, et une authentification par session cookies sur un Identity Provider legacy (Keycloak 15, non maintenu depuis 18 mois). L'équipe technique comprend 18 développeurs, 3 SREs, et un RSSI à mi-temps partagé avec une filiale. Le stack principal utilise Java Spring Boot, PostgreSQL, et un déploiement Kubernetes sur un cloud souverain certifié HDS.

### Problème
Un audit de sécurité mandaté par l'ANSSI dans le cadre du renouvellement de la certification HDS révèle des failles critiques : communication inter-services non chiffrée permettant un sniffing trivial du trafic interne, accès développeur trop permissif (tous les devs ont accès à toutes les bases de données de production via le VPN sans segmentation), absence de segmentation réseau entre les environnements de développement et de production, et tokens de session avec un TTL de 30 jours sans rotation ni révocation possible. Le rapport conclut que la compromission d'un seul service permettrait un mouvement latéral vers toutes les données patients — classé risque "critique" avec un score CVSS de 9.1. L'entreprise a 6 mois pour remédier sous peine de perte de la certification HDS, ce qui entraînerait la résiliation automatique des contrats avec les 150 établissements. Le coût potentiel d'une fuite de données de santé est estimé à 8M EUR (amendes CNIL + indemnités + perte de contrats).

### Approche
1. **mTLS entre tous les services** : Déploiement d'un service mesh (Istio) sur le cluster Kubernetes en mode strict. Chaque service dispose d'un certificat TLS géré par cert-manager avec rotation automatique toutes les 24h via une CA interne (Vault PKI). Communication inter-services chiffrée et mutuellement authentifiée — un service non autorisé ne peut plus communiquer, même s'il est déployé dans le même namespace. La migration a été réalisée en 3 phases sur 6 semaines : mode permissive (logging only), mode warning (détection sans blocage), puis mode strict (blocage des communications non-mTLS). Chaque phase a été validée par l'équipe SRE avant passage à la suivante.
2. **Migration vers OAuth 2.1 + Passkeys** : Remplacement de Keycloak 15 par Keycloak 24 avec support OAuth 2.1, PKCE obligatoire pour tous les clients (public et confidential), et intégration des passkeys (WebAuthn/FIDO2) comme méthode d'authentification primaire pour le personnel soignant. Access tokens avec TTL de 5 minutes signés en EdDSA, refresh token rotation on use avec détection de réutilisation (token replay detection). La migration a été réalisée en shadow mode pendant 4 semaines : les deux systèmes authentifiaient en parallèle, avec un fallback automatique sur l'ancien système en cas d'erreur. Les 150 établissements ont été migrés par vagues de 15 sur une période de 3 mois.
3. **Policy engine centralisé** : Déploiement d'Open Policy Agent (OPA) comme policy engine centralisé évalué en sidecar dans chaque pod Kubernetes. Toutes les décisions d'autorisation passent par OPA avec des policies écrites en Rego, versionnées dans un repo Git dédié et testées unitairement en CI (350 assertions couvrant tous les rôles et cas limites). RBAC granulaire remplaçant l'accès binaire : les développeurs n'accèdent qu'aux services de leur squad, les SREs ont un accès just-in-time limité à 30 minutes via un workflow d'approbation Slack, et les accès production sont audités en temps réel.
4. **Layered authorization** : Implémentation de RLS (Row-Level Security) dans PostgreSQL pour l'isolation des données par établissement. Chaque requête est filtrée au niveau base de données par le `tenant_id` extrait du JWT et injecté dans le contexte PostgreSQL, indépendamment de la couche applicative. Un trigger PostgreSQL bloque toute requête sans `tenant_id` défini. Cette couche de défense en profondeur garantit l'isolation même en cas de bug dans la couche OPA ou dans le code applicatif.

### Résultat
- Certification HDS maintenue — audit de remediation passé avec zéro non-conformité critique et seulement 2 observations mineures (corrigées en 1 semaine)
- Surface d'attaque réduite de 85% : un service compromis ne peut plus accéder aux données d'autres services grâce au mTLS et à la segmentation OPA
- Temps de propagation d'un incident de sécurité (blast radius) réduit de "toute l'infra" à "un service isolé", validé par un exercice de red team trimestriel
- 92% des utilisateurs soignants adoptent les passkeys en 3 mois (UX supérieure aux mots de passe + formation de 15 minutes par établissement)
- Temps d'accès développeur à la production passé de "permanent" à "just-in-time" (30 min max par session avec approbation)
- Réduction de 95% des accès non nécessaires en production, identifiée par un audit post-migration comparant les logs d'accès avant/après

### Leçons apprises
- Le Zero Trust n'est pas un produit mais une architecture — il faut repenser chaque couche de communication et d'accès. Chez MédiCloud, le projet a mobilisé 4 personnes à plein temps pendant 5 mois. Sous-estimer cet investissement conduit à une implémentation partielle qui crée un faux sentiment de sécurité.
- Le service mesh (Istio) simplifie le mTLS mais ajoute une complexité opérationnelle significative (debugging du sidecar proxy, overhead de latence de 2-5ms par hop, consommation mémoire) — prévoir 2 mois de montée en compétence de l'équipe SRE et un environnement de staging identique à la production.
- Les passkeys offrent une UX supérieure ET une sécurité supérieure — c'est le rare cas où sécurité et expérience utilisateur s'alignent parfaitement. Le personnel soignant, initialement sceptique, est devenu le meilleur ambassadeur de la solution.
- La migration en shadow mode (ancien et nouveau système en parallèle) est le seul moyen sûr de migrer l'authentification sans incident — le surcoût d'infrastructure pendant 4 semaines est négligeable comparé au risque d'un lockout massif des utilisateurs.

---

## Cas 2 : Sécurisation d'une API multi-tenant B2B

### Contexte
ApiForge, éditeur d'une plateforme d'intégration API (iPaaS) pour les ETI, gère 80 clients avec des milliers de workflows automatisés transitant par la plateforme. Fondée il y a 5 ans, l'entreprise traite 2M d'appels API par jour et s'est positionnée comme une alternative européenne à Zapier et Make pour les entreprises soumises à des contraintes réglementaires. L'architecture est un monolithe Node.js/Express avec une base PostgreSQL partagée, déployé sur AWS ECS. L'équipe de 15 développeurs travaille en 3 squads (intégrations, plateforme, croissance). L'authentification utilise des API keys statiques stockées en variables d'environnement côté client, sans expiration ni mécanisme de rotation.

### Problème
Un incident de sécurité majeur déclenche une crise : une API key d'un client a fuité dans un dépôt GitHub public (commitée accidentellement par un développeur du client dans un fichier de configuration). Avant la détection (72h, alerté par un chercheur en sécurité via le programme de bug bounty), un attaquant a pu accéder aux données de ce client et, en exploitant une faille d'IDOR (Insecure Direct Object Reference) dans l'endpoint `/api/workflows/{id}`, a consulté les configurations de 12 autres clients contenant des credentials de services tiers. L'investigation forensic (limitée par l'absence de logs détaillés) révèle : aucune isolation des données par tenant au niveau base de données, API keys sans expiration ni rotation depuis la création des comptes (certaines ont 4 ans), absence de rate limiting permettant le scraping massif, et logs insuffisants pour reconstituer l'étendue exacte de la compromission. L'incident a entraîné la notification de 13 clients, un signalement CNIL, et la perte de 3 prospects enterprise en cours de négociation.

### Approche
1. **Row-Level Security** : Migration vers une architecture où chaque requête SQL est filtrée par le `tenant_id` via des PostgreSQL RLS policies. Le `tenant_id` est extrait du JWT et injecté dans le contexte de session PostgreSQL (`SET app.current_tenant`). Impossible d'accéder aux données d'un autre tenant, même avec une faille applicative de type IDOR. La migration a été réalisée en 4 semaines avec un script de vérification exhaustif qui a testé chaque endpoint (380 routes) avec 2 tenants différents pour confirmer l'isolation. Un trigger `BEFORE INSERT` et `BEFORE UPDATE` bloque toute tentative de modification du `tenant_id` d'une ressource existante.
2. **OAuth 2.1 + API keys rotatives** : Remplacement des API keys statiques par un système OAuth 2.1 Client Credentials pour le M2M, avec des tokens JWT signés Ed25519 et un TTL de 1 heure. Les API keys legacy sont migrées vers des tokens avec TTL de 90 jours et rotation automatique. Notification email 30 jours avant expiration, rappel à 7 jours, et désactivation automatique à l'échéance. Un mécanisme de "key pair" permet aux clients de créer une nouvelle clé avant de révoquer l'ancienne (zero-downtime rotation). Le secret scanning GitHub (via GitHub Advanced Security) alerte en temps réel si une clé ApiForge est détectée dans un dépôt public.
3. **Rate limiting et abuse detection** : Implémentation de rate limiting par tenant (Redis + token bucket algorithm) avec des limites par endpoint et par tenant, configurables par plan tarifaire (Starter: 100 req/min, Pro: 1000 req/min, Enterprise: custom). Détection d'anomalies basée sur un modèle de baseline comportemental : alertes sur les pics de requêtes (> 3 écarts-types), les accès à des ressources inhabituelles (endpoints jamais utilisés par ce tenant), et les patterns de scanning séquentiel (énumération d'IDs). Un WAF (AWS WAF) en amont bloque les patterns d'attaque connus (SQLi, XSS, path traversal).
4. **Security monitoring** : Logging structuré de chaque action avec `tenant_id`, `user_id`, `ip`, `action`, `resource_id`, `response_code` et `duration` dans un format JSON normalisé. Dashboard de sécurité en temps réel (Datadog Security Monitoring) avec alertes sur les événements critiques : failed auth attempts (> 5/min par IP), privilege escalation attempts, cross-tenant access attempts (détectés par une règle comparant le `tenant_id` du JWT avec celui de la ressource accédée). Rétention des logs de sécurité de 13 mois pour conformité SOC 2. Un rapport de sécurité automatisé est généré mensuellement pour chaque client enterprise.

### Résultat
- Isolation des données garantie au niveau base de données — même une faille applicative ne permet plus d'accéder aux données d'un autre tenant, validé par un pentest externe trimestriel
- Temps de détection d'incident (MTTD) réduit de 72h à 15 minutes grâce au monitoring et aux alertes en temps réel
- Zéro fuite de données cross-tenant depuis l'implémentation (12 mois), confirmé par 4 pentests externes
- Conformité SOC 2 Type II obtenue après 6 mois d'audit — requis par 60% des prospects enterprise et désormais un argument commercial majeur
- API keys sans rotation éliminées — 100% des clients migrés vers le nouveau système en 4 mois, avec seulement 3 tickets support liés à la migration
- Regain de confiance des clients : le Net Promoter Score est remonté de -15 (post-incident) à +25 en 6 mois grâce à la transparence sur les mesures correctives

### Leçons apprises
- Le RLS au niveau PostgreSQL est la dernière ligne de défense la plus robuste pour le multi-tenant — il fonctionne même quand le code applicatif a des bugs. C'est un investissement de 4 semaines qui protège contre des classes entières de vulnérabilités (IDOR, injection, erreurs de logique).
- Les API keys statiques sont une bombe à retardement — toute API key doit avoir une expiration et un mécanisme de rotation automatique. Chez ApiForge, 23% des clés n'avaient jamais été changées depuis la création du compte. Un seul leak suffit à compromettre la plateforme entière.
- Le security monitoring proactif est aussi important que la prévention — sans detection capabilities, les incidents durent des jours au lieu de minutes. Le coût du monitoring (5K EUR/mois chez ApiForge) est dérisoire comparé au coût d'un incident non détecté.
- La communication transparente post-incident est cruciale pour la rétention — ApiForge a publié un postmortem détaillé, offert 3 mois gratuits aux clients affectés, et organisé un webinar sur les mesures correctives. Trois des 12 clients affectés sont devenus des références commerciales.

---

## Cas 3 : Implémentation de passkeys et passwordless pour un SaaS grand public

### Contexte
FitTrack, application mobile et web de fitness avec 2M d'utilisateurs actifs mensuels, est un des leaders du marché français du coaching sportif numérique. L'application utilise une authentification classique email/mot de passe avec TOTP (Google Authenticator) comme MFA optionnel. Le taux d'adoption du MFA est de 8%, malgré des campagnes de sensibilisation répétées. L'application est développée en React Native (mobile iOS et Android) et Next.js (web) avec un backend Node.js (Fastify) et PostgreSQL. L'équipe technique comprend 10 développeurs (4 mobile, 3 frontend web, 3 backend) et un responsable sécurité. FitTrack traite des données de santé (fréquence cardiaque, poids, conditions médicales) qui sont soumises à des obligations renforcées en matière de protection des données personnelles.

### Problème
L'entreprise subit 15-20 tentatives de credential stuffing par semaine (utilisation de mots de passe volés sur d'autres services), avec en moyenne 2-3 compromissions de comptes réussies par mois nécessitant une intervention manuelle du support. 30% des tickets support (450/mois) concernent des problèmes de mot de passe (oubli, réinitialisation, blocage MFA TOTP après changement de téléphone). Le taux de conversion signup est de 35% — l'analyse du funnel montre que 40% des abandons se font à l'étape de création de mot de passe (complexité requise perçue comme excessive : 12 caractères, majuscule, chiffre, caractère spécial). La CNIL recommande un renforcement de l'authentification suite à un contrôle, citant spécifiquement la faible adoption du MFA et le stockage de données de santé sans authentification forte comme point de vigilance.

### Approche
1. **Passkeys comme méthode primaire** : Implémentation de WebAuthn/FIDO2 via la librairie SimpleWebAuthn côté serveur et les APIs natives des navigateurs (Web Authentication API) et OS (Credential Manager Android, ASWebAuthenticationSession iOS). Les passkeys sont proposées comme méthode d'inscription par défaut via un prompt attractif expliquant les bénéfices ("Connectez-vous avec votre empreinte — plus jamais de mot de passe"), avec email/mot de passe accessible via un lien discret "Utiliser un mot de passe à la place". La synchronisation cross-device est gérée nativement par les passkey providers (iCloud Keychain, Google Password Manager). Un travail UX de 3 semaines a été nécessaire pour concevoir un flow d'inscription qui ne désoriente pas les utilisateurs habitués aux mots de passe.
2. **Magic links comme alternative** : Pour les utilisateurs sur des appareils ne supportant pas les passkeys (navigateurs anciens, feature phones), implémentation de magic links par email (lien à usage unique, TTL de 10 minutes, rate limited à 3 tentatives par email par heure). Les magic links utilisent un token JWT signé contenant l'ID utilisateur et un nonce, stocké en base avec un flag `consumed` pour empêcher la réutilisation. Un mécanisme anti-phishing affiche les 4 derniers caractères de l'email de destination dans la page de confirmation.
3. **Migration progressive** : Les utilisateurs existants sont invités à créer une passkey lors de leur prochaine connexion via un prompt non-intrusif (bottom sheet mobile, modal web) avec option "Me rappeler plus tard" (rappel après 7 jours). Campagne email ciblée pour les utilisateurs à haut risque : mots de passe faibles détectés via HaveIBeenPwned API (12% des comptes), comptes victimes de tentatives de credential stuffing, et utilisateurs sans MFA stockant des données de santé. Le prompt est A/B testé : la variante "sécurité" ("Protégez votre compte") performe 30% moins bien que la variante "simplicité" ("Connectez-vous en 1 seconde").
4. **BFF pattern pour le web** : Implémentation d'un Backend-For-Frontend (Next.js API Routes) qui gère les sessions via des cookies HttpOnly/Secure/SameSite=Strict avec un TTL de 15 minutes et renouvellement automatique. Les tokens ne sont jamais exposés au JavaScript côté client, éliminant les risques XSS sur les credentials. Le BFF proxy les appels API avec le token en header Authorization, et gère la rotation des refresh tokens côté serveur. Cette architecture a ajouté 3ms de latence au p99 mais a éliminé une classe entière de vulnérabilités client-side.

### Résultat
- Credential stuffing éliminé pour les utilisateurs avec passkeys (impossible par design — pas de secret partagé à voler)
- Taux de conversion signup passé de 35% à 52% (+48%) — les passkeys suppriment la friction de création de mot de passe, point validé par un A/B test sur 100K visiteurs
- Tickets support liés aux mots de passe réduits de 70% (de 450 à 135/mois), économisant 1.5 ETP de support
- 45% des utilisateurs actifs ont migré vers les passkeys en 6 mois (adoption organique, sans forçage), avec un objectif de 70% à 12 mois
- Temps de login médian réduit de 12 secondes (email + mot de passe) à 2 secondes (passkey biométrique), mesuré via le tracking du funnel de connexion
- Conformité CNIL validée lors du contrôle de suivi — l'authentification est considérée comme "état de l'art" et citée positivement dans le rapport

### Leçons apprises
- Les passkeys sont la meilleure amélioration de sécurité qui améliore AUSSI l'UX — c'est l'argument le plus convaincant pour les stakeholders. Chez FitTrack, le ROI s'est avéré positif en 3 mois grâce à la réduction du support et l'augmentation de la conversion.
- La migration progressive est essentielle — forcer les passkeys provoque une perte d'utilisateurs mesurée à 8% dans un test pilote. Proposer, ne pas imposer, et optimiser le prompt avec de l'A/B testing. La variante "simplicité" surperforme systématiquement la variante "sécurité".
- Le BFF pattern est indispensable pour les SPAs — stocker des tokens dans le navigateur (même en mémoire) est inférieur en sécurité aux cookies HttpOnly gérés par le BFF. Le surcoût d'implémentation est de 2 semaines mais élimine les vulnérabilités XSS sur les credentials.
- La synchronisation cross-device des passkeys (iCloud Keychain, Google Password Manager) est transparente pour 95% des utilisateurs mais les 5% restants (multi-écosystème Apple + Android) nécessitent un fallback robuste — les magic links comblent parfaitement ce gap.
